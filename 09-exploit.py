from assets.loader import gather_day, input_day
from collections import deque
from itertools import accumulate

gather_day(9)

with open(input_day(9), 'r') as f:
    stream = [int(l.strip()) for l in f.readlines()]

# From day 1
def seek(target: int, choices: list) -> tuple:
    solution = tuple()
    queue = deque(sorted(choices))
    little, large = queue.popleft(), queue.pop()
    while not solution:
        if little + large > target:
            if not queue: break
            large = queue.pop()
        elif little + large < target:
            if not queue: break
            little = queue.popleft()
        else: 
            solution = (little, large)
    else:
        return solution

### Part 1 ###
buffer, idx, solution = 25, 24, True
while solution:
    idx += 1
    solution = seek(stream[idx], stream[idx-buffer:idx])
else:
    print(f'First failing index is #{idx}: {stream[idx]:,}.')

### Part 2 ###
target = stream[664]  # 1,721,308,972
solution = tuple()
ilittle, ilarge = 0, 1

while not solution:
    try:
        if sum(stream[ilittle:ilarge]) < target:
            ilarge +=1
        elif sum(stream[ilittle:ilarge]) > target:
            ilittle +=1
        else: 
            solution = (ilittle, ilarge-1)
    except IndexError:
        break

print(f'Solution is [#{solution[0]}: {stream[solution[0]]:,} ... '
      f'#{solution[1]}: {stream[solution[1]]:,}] (sum of min/max is '
      f'{min(stream[solution[0]:solution[1]+1])+max(stream[solution[0]:solution[1]+1])}; '
      f'sum of range is {sum(stream[solution[0]:solution[1]+1]):,}).')
